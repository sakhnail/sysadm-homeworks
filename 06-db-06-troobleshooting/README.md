1. Для остановки запросов пользователя можно использовать <code>db.killOp(<opid of the query to kill>)</code>. Для определения opid:
```shell
db.aggregate( [
   { $currentOp : { allUsers: true, localOps: true } },
   { $match : <filter condition> } // Optional.  Specify the condition to find the op.
                                   // e.g. { op: "getmore", "command.collection": "someCollection" }
] )
```
Возможно перестроение индексов поможет в решении проблемы долгих запросов и использовать <code>mongostat</code> для выявления конкретных запросов.

2. Необходимо выполнить и проверить:
 * Убедиться, что slow-команды не блокируют сервер: <code>redis- cli SLOWLOG GET N</code>
 * Отключить huge page: <code>echo never > /sys/kernel/mm/transparent_hugepage/enabled</code>
 * Возможно, если используется виртуальная машина, присутствует внутренняя задержка: <code> ./redis-cli --intrinsic-latency 100</code>
 * Включить функцию монитора задержки Redis: <code>CONFIG SET latency-monitor-threshold 100</code>
 * Возможно сетевая проблема
 * Или просто не хватка оперативной памяти

3. Потерянное соединение с сервером MySQL

<p>Обычно это указывает на проблемы с подключением к сети, и мы должны проверить состояние сети, если эта ошибка возникает часто.</p>
<p>Иногда форма "во время запроса" возникает, когда миллионы строк отправляются как часть одного или нескольких запросов. Если это действительно происходит, то мы можем попытаться увеличить значение net_read_timeout со своего значения по умолчанию от 30 секунд до 60 секунд или дольше, достаточного для завершения передачи данных.</p>
<p>Реже это может произойти, когда клиент пытается выполнить первоначальное подключение к серверу. В этом случае, если значение connect_timeout установлено всего на несколько секунд, можно решить проблему, увеличив ее до десяти секунд, возможно, больше, в зависимости от качества канала связи. Тут можно увеличить значение параметра connect_timeout на большее значение. Командой SHOW GLOBAL STATUS LIKE 'Aborted_connects' можно посмотреть значение и если оно увеличивается с возникновением ошибки, то увеличение таймаута должно помочь</p>
<p>Возможно, проблема связана с большим значением BLOB, превышающий параметр max_allowed_packet</p>

4. Причина Out-Of-Memory Killer

Нехватка оперативной памяти, необходимо увеличить объем оперативной памяти на сервере. Или можно сделать так: <code>sudo echo -100 > /proc/*PID*/oom_score_adj</code>, так мы скажем киллеру не убивать процесс Postgres 
